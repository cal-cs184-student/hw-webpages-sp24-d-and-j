<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=r3oQQBWBLofdqMg7Xagtphmx_9IXfkwuEX_E26t7NMz0vzZTLk4Jh8uoFf3Lfl2H6-YTWmBS9VnyT6chnVesbxuZhwFENB-Laec4FaMajlyJ5RRpxu95W3ceec3F2nwR);.lst-kix_8wup04gzhtob-5>li{counter-increment:lst-ctn-kix_8wup04gzhtob-5}.lst-kix_207k7o1r4gx-2>li:before{content:"\0025a0   "}ol.lst-kix_8wup04gzhtob-7.start{counter-reset:lst-ctn-kix_8wup04gzhtob-7 0}.lst-kix_207k7o1r4gx-0>li:before{content:"\0025cf   "}.lst-kix_207k7o1r4gx-4>li:before{content:"\0025cb   "}.lst-kix_207k7o1r4gx-1>li:before{content:"\0025cb   "}.lst-kix_207k7o1r4gx-5>li:before{content:"\0025a0   "}ol.lst-kix_8wup04gzhtob-0.start{counter-reset:lst-ctn-kix_8wup04gzhtob-0 0}ol.lst-kix_8wup04gzhtob-4.start{counter-reset:lst-ctn-kix_8wup04gzhtob-4 0}.lst-kix_207k7o1r4gx-3>li:before{content:"\0025cf   "}ul.lst-kix_207k7o1r4gx-1{list-style-type:none}ul.lst-kix_207k7o1r4gx-2{list-style-type:none}ul.lst-kix_207k7o1r4gx-0{list-style-type:none}ul.lst-kix_207k7o1r4gx-5{list-style-type:none}.lst-kix_207k7o1r4gx-8>li:before{content:"\0025a0   "}ul.lst-kix_207k7o1r4gx-6{list-style-type:none}ul.lst-kix_207k7o1r4gx-3{list-style-type:none}ul.lst-kix_207k7o1r4gx-4{list-style-type:none}.lst-kix_207k7o1r4gx-6>li:before{content:"\0025cf   "}ul.lst-kix_207k7o1r4gx-7{list-style-type:none}ul.lst-kix_207k7o1r4gx-8{list-style-type:none}.lst-kix_207k7o1r4gx-7>li:before{content:"\0025cb   "}ol.lst-kix_8wup04gzhtob-8.start{counter-reset:lst-ctn-kix_8wup04gzhtob-8 0}.lst-kix_8wup04gzhtob-4>li{counter-increment:lst-ctn-kix_8wup04gzhtob-4}.lst-kix_8wup04gzhtob-7>li{counter-increment:lst-ctn-kix_8wup04gzhtob-7}ol.lst-kix_8wup04gzhtob-5.start{counter-reset:lst-ctn-kix_8wup04gzhtob-5 0}ol.lst-kix_8wup04gzhtob-2.start{counter-reset:lst-ctn-kix_8wup04gzhtob-2 0}.lst-kix_8wup04gzhtob-6>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-6,decimal) ". "}.lst-kix_8wup04gzhtob-2>li{counter-increment:lst-ctn-kix_8wup04gzhtob-2}.lst-kix_8wup04gzhtob-8>li{counter-increment:lst-ctn-kix_8wup04gzhtob-8}.lst-kix_8wup04gzhtob-4>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-4,lower-latin) ". "}.lst-kix_8wup04gzhtob-8>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-8,lower-roman) ". "}ol.lst-kix_8wup04gzhtob-8{list-style-type:none}ol.lst-kix_8wup04gzhtob-7{list-style-type:none}.lst-kix_8wup04gzhtob-5>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-5,lower-roman) ". "}.lst-kix_8wup04gzhtob-7>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-7,lower-latin) ". "}ol.lst-kix_8wup04gzhtob-4{list-style-type:none}.lst-kix_8wup04gzhtob-1>li{counter-increment:lst-ctn-kix_8wup04gzhtob-1}ol.lst-kix_8wup04gzhtob-3{list-style-type:none}ol.lst-kix_8wup04gzhtob-6.start{counter-reset:lst-ctn-kix_8wup04gzhtob-6 0}ol.lst-kix_8wup04gzhtob-6{list-style-type:none}ol.lst-kix_8wup04gzhtob-5{list-style-type:none}ol.lst-kix_8wup04gzhtob-0{list-style-type:none}ol.lst-kix_8wup04gzhtob-2{list-style-type:none}ol.lst-kix_8wup04gzhtob-1{list-style-type:none}ol.lst-kix_8wup04gzhtob-1.start{counter-reset:lst-ctn-kix_8wup04gzhtob-1 0}ol.lst-kix_8wup04gzhtob-3.start{counter-reset:lst-ctn-kix_8wup04gzhtob-3 0}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}.lst-kix_8wup04gzhtob-0>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-0,decimal) ". "}.lst-kix_8wup04gzhtob-0>li{counter-increment:lst-ctn-kix_8wup04gzhtob-0}.lst-kix_8wup04gzhtob-1>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-1,lower-latin) ". "}.lst-kix_8wup04gzhtob-6>li{counter-increment:lst-ctn-kix_8wup04gzhtob-6}.lst-kix_8wup04gzhtob-2>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-2,lower-roman) ". "}.lst-kix_8wup04gzhtob-3>li{counter-increment:lst-ctn-kix_8wup04gzhtob-3}.lst-kix_8wup04gzhtob-3>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-3,decimal) ". "}ol{margin:0;padding:0}table td,table th{padding:0}.c23{margin-left:108pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c13{margin-left:72pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c11{margin-left:0pt;padding-top:0pt;padding-left:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c2{margin-left:-72pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt;height:11pt}.c19{margin-left:-72pt;padding-top:18pt;padding-bottom:6pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c26{margin-left:-72pt;padding-top:0pt;padding-bottom:16pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c8{margin-left:-72pt;padding-top:0pt;padding-bottom:3pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c3{margin-left:-72pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c18{margin-left:-72pt;padding-top:0pt;padding-bottom:6pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c17{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Helvetica Neue";font-style:normal}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c27{color:#000000;font-weight:300;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Nunito"}.c14{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c1{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c6{font-size:12pt;font-family:"Courier New";font-weight:400}.c20{font-weight:400;font-size:26pt;font-family:"Helvetica Neue"}.c25{font-weight:400;font-size:16pt;font-family:"Arial"}.c9{font-weight:400;font-size:16pt;font-family:"Helvetica Neue"}.c4{font-size:12pt;font-family:"Roboto Mono";font-weight:300}.c24{background-color:#fafafa;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c29{font-size:12pt;font-family:"Nunito";font-weight:300}.c10{font-weight:400;font-size:11pt;font-family:"Helvetica Neue"}.c5{font-weight:700;font-size:12pt;font-family:"Helvetica Neue"}.c0{font-size:12pt;font-family:"Helvetica Neue";font-weight:300}.c22{font-weight:400;font-size:11pt;font-family:"Arial"}.c21{padding:0;margin:0}.c16{color:inherit;text-decoration:inherit}.c28{font-weight:400;font-family:"Helvetica Neue"}.c7{page-break-after:avoid}.c15{font-style:italic}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:0pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:0pt;font-family:"Helvetica Neue";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c24 doc-content"><p class="c3"><span>Webpage: </span><span class="c14"><a class="c16" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-d-and-j/hw2/index.html&amp;sa=D&amp;source=editors&amp;ust=1709099166235659&amp;usg=AOvVaw3YiTWmCWwMOnh9JQp988h_">https://cal-cs184-student.github.io/hw-webpages-sp24-d-and-j/hw2/index.html</a></span><span class="c1 c22">&nbsp;</span></p><p class="c7 c8 title" id="h.ynuhj7g8d1"><span class="c1 c20">HW1: Meshedit</span></p><p class="c7 c26 subtitle" id="h.b0gs0jwziuy2"><span class="c17">By: Daniel Hsu and Joseph Liu</span></p><h2 class="c7 c19" id="h.66gqg7jykr8r"><span class="c1 c9">Task 1 - Bezier Curves with 1D de Casteljau Subdivision</span></h2><p class="c3"><span class="c0">De Casteljau&rsquo;s algorithm is a recursive formula that eventually evaluates to a smooth Bezier curve based on the control point inputs. It linearly interpolates a point between 2 parent points (be that the original control point or a derived intermediate point) to form the next set of intermediate points. This process is repeated enough times for </span><img src="images/image1.png"><span class="c1 c0">&nbsp;on every subsequently created set of points until only 1 point is created when we apply de Casteljau&rsquo;s algorithm. That final point is a point that is a part of the final Bezier curve.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 395.52px; height: 279.76px;"><img alt="" src="images/image25.png" style="width: 395.52px; height: 279.76px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 395.52px; height: 277.85px;"><img alt="" src="images/image18.png" style="width: 395.52px; height: 277.85px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1 c5">(Left) Student-made 6-control-point Bezier curve. (Right) Same curve with moved control points and different t.</span></p><p class="c2"><span class="c1 c0"></span></p><h2 class="c19 c7" id="h.p48iqjj53jy9"><span class="c1 c9">Task 2 - Bezier Surfaces with Separable 1D de Casteljau</span></h2><p class="c3"><span class="c1 c0">Just as how we used de Casteljau&rsquo;s algorithm to create a smooth curve using a 1D array of 2D points, we can use it in a similar manner to create a smooth surface using a 2D array of 3D points. Given the 2D array of points, for each row of the array we can run de Casteljau&rsquo;s algorithm to create Bezier curves for each of them. This is equivalent to performing all the nested lerps based on one of the parameterized variables, u. Then for each of the curves, sample its point at a value u; these points will be the control points for one final run of de Casteljau&rsquo;s algorithm. Using those control points, changing the parameter v will provide us with the final Bezier curve. If we repeat this step of holding a constant value u and performing de Casteljau&rsquo;s algorithm on our obtained control points with parameter v, we will obtain many Bezier curves. Let&rsquo;s say, without loss of generality, we sample u from 0 to 1 at infinitesimally small differences in the increase of the current sample u to the next sample u, we would get an infinite number of Bezier curves just from all the values between 0 &lt; u &lt; 1. Graphing all the obtained Bezier curves on a 3D plane, we can see that all the curves reside neatly beside each other, forming a smooth surface. Thus, we are able to evaluate Bezier surfaces with de Casteljau.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 597.50px; height: 423.82px;"><img alt="" src="images/image14.png" style="width: 597.50px; height: 423.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1 c5">/bez/teapot.bez constructed with Bezier surfaces</span></p><p class="c2"><span class="c1 c0"></span></p><h2 class="c19 c7" id="h.3lkn161017bg"><span class="c1 c9">Task 3 - Area Weighted Vertex Normals</span></h2><p class="c3"><span class="c1 c0">We implemented area-weighted vertex normals by first going through all the faces fanning out from the Vertex, adding up the area-weighted normals of those faces, and normalizing the sum vector. More specifically for each face (represented by a half-edge; we are traversing half-edges):</span></p><ol class="c21 lst-kix_8wup04gzhtob-0 start" start="1"><li class="c11 li-bullet-0"><span class="c1 c0">If the half-edge is a boundary edge (and therefore the face is a boundary face) we skip it because it doesn&rsquo;t have a normal.</span></li><li class="c11 li-bullet-0"><span class="c0">Otherwise, we get the normal </span><span class="c0 c15">n</span><span class="c0">&nbsp;of the face using </span><span class="c4">h-&gt;face()-&gt;normal()</span><span class="c1 c0">...</span></li></ol><ol class="c21 lst-kix_8wup04gzhtob-1 start" start="1"><li class="c13 li-bullet-0"><span class="c0">[</span><span class="c14 c0"><a class="c16" href="#h.8xl0657tlbqo">Debugging from Task 5</a></span><span class="c1 c0">] If the normal is NaN, skip this face.</span></li></ol><ol class="c21 lst-kix_8wup04gzhtob-2 start" start="1"><li class="c23 li-bullet-0"><span class="c0">In C++, a float </span><span class="c4">f</span><span class="c0">&nbsp;is NaN if &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c4">f != f</span><span class="c29">&nbsp;is true.</span></li></ol><ol class="c21 lst-kix_8wup04gzhtob-0" start="3"><li class="c11 li-bullet-0"><span class="c0">&hellip;find the area </span><span class="c0 c15">a</span><span class="c1 c0">&nbsp;of the face&hellip;</span></li></ol><ol class="c21 lst-kix_8wup04gzhtob-1 start" start="1"><li class="c13 li-bullet-0"><span class="c1 c0">area = &frac12; W x H, so we get two edges, take the cross product, and halve it.</span></li><li class="c13 li-bullet-0"><span class="c0">[</span><span class="c14 c0"><a class="c16" href="#h.8xl0657tlbqo">Debugging from Task 5</a></span><span class="c1 c0">] If the area is NaN, skip this face.</span></li></ol><ol class="c21 lst-kix_8wup04gzhtob-0" start="4"><li class="c11 li-bullet-0"><span class="c0">&hellip;and add the weighted normal to the sum: </span><span class="c4">normal_sum += n * a</span><span class="c1 c0">&nbsp;</span></li></ol><p class="c3"><span class="c1 c0">Then we normalize the sum of the face normals to get the average-weighted vertex normal.</span></p><p class="c2"><span class="c0 c1"></span></p><p class="c3"><span class="c1 c0">The reasoning for skipping the faces with NaN normals and areas is elaborated in the debugging section of the Task 5 writeup. In brief, when flipping an edge it is possible to run into the case where an edge is flipped such that it lines up with the two triangles&rsquo; bases and forms a line. In this case the normal (and area apparently) become undefined. The reason skipping these is valid is because this face is technically zero area anyways, so it doesn&rsquo;t contribute to the weighted normal sum; it&rsquo;s just the code sees it as NaN instead of 0.</span></p><p class="c2"><span class="c1 c0"></span></p><p class="c3"><span class="c1 c5">Teapot Shading without Vertex Normals:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 711.53px; height: 495.43px;"><img alt="" src="images/image30.png" style="width: 711.53px; height: 495.43px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1 c5">Teapot Shading with Vertex Normals:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 714.50px; height: 497.47px;"><img alt="" src="images/image31.png" style="width: 714.50px; height: 497.47px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1 c0"></span></p><h2 class="c19 c7" id="h.ppvjqtsnekc8"><span class="c28">Task 4 - Edge Flip</span></h2><p class="c3"><span class="c0">We implemented edge flip by using a series of pointer reassignments. First we drew out a simple mesh before and after the edge flip as seen in the image below. We named every vertex (4), edge (5), face (2), and half-edge (10) that exists in this simple mesh and noted their values before and after the edge flip. Then in the code, we retrieved these elements and reassigned the elements that has a different value (for example, vertex </span><span class="c0 c15">b</span><span class="c0">&rsquo;s half-edge changes from </span><span class="c0 c15">h1</span><span class="c0">&nbsp;to </span><span class="c0 c15">h7</span><span class="c0">, whereas </span><span class="c0 c15">a</span><span class="c0">&rsquo;s remains as </span><span class="c0 c15">h4</span><span class="c1 c0">). We reassigned the pointers in the following order: Vertex, Edge, Face, Half-Edge.</span></p><p class="c3"><span class="c0">Vertices, edges, and faces were reassigned by assigning their half-edge pointer to one that was relevant to it, while half-edge pointers were reassigned using the </span><span class="c4">setNeighbors()</span><span class="c1 c0">&nbsp;method. No new elements were created.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 836.09px; height: 807.26px;"><img alt="" src="images/image27.jpg" style="width: 836.09px; height: 807.26px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1 c5"></span></p><p class="c3"><span class="c5">Unmodified Teapot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmodified Teapot (Smooth)</span></p><h2 class="c7 c18" id="h.r29toexk9olx"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 421.86px; height: 302.64px;"><img alt="" src="images/image3.png" style="width: 421.86px; height: 302.64px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 425.08px; height: 304.64px;"><img alt="" src="images/image6.png" style="width: 425.08px; height: 304.64px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h2><p class="c3"><span class="c5">Teapot with Edge Flips&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Teapot with Edge Flips (Smooth)</span></p><h2 class="c18 c7" id="h.8iaq59qdq41u"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 427.90px; height: 304.48px;"><img alt="" src="images/image21.png" style="width: 427.90px; height: 304.48px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 428.27px; height: 306.85px;"><img alt="" src="images/image20.png" style="width: 428.27px; height: 306.85px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h2><p class="c12"><span class="c1 c22"></span></p><p class="c2"><span class="c1 c22"></span></p><p class="c2"><span class="c1 c22"></span></p><h2 class="c19 c7" id="h.4gw8wxib6gry"><span class="c1 c9">Task 5 - Edge Split</span></h2><p class="c3"><span class="c0">The thought process for edge split was similar to edge flip, except now we have new elements. We started by naming the existing elements: 4 vertices, 5 edges, 2 faces, 10 half-edges. Then we drew out the resulting simple mesh after the edge split, as seen in the image below. This would now have 5 vertices, 8 edges, 4 faces, and 16 half edges. New elements are indicated with the purple + symbol (note that </span><span class="c0 c15">e0</span><span class="c0">, which is edge </span><span class="c0 c15">cb</span><span class="c0">, is not deleted, but rather reassigned to be edge </span><span class="c0 c15">cm</span><span class="c0">&nbsp;in the resulting mesh). We then created the new elements in this order: Vertex, Edge, Face, Half-Edge. When creating the new vertex, its position was set to be the midpoint of the original edge </span><span class="c0 c15">e0</span><span class="c0">, which we got by taking the average of the vertex positions of </span><span class="c0 c15">e0</span><span class="c0">, which are vertices </span><span class="c0 c15">c </span><span class="c0">and </span><span class="c0 c15">b</span><span class="c0">&nbsp;as seen below. Next we assigned/reassigned the pointers based on the modified diagram, using the same process as in edge flip. The outside half-edges (</span><span class="c0 c15">h4, h6, h8, h10</span><span class="c1 c0">) were untouched since they don&rsquo;t change as a result of the edge split.</span></p><p class="c3"><span class="c0">As new elements are added, specifically two new edges and a new vertex, we made sure to set the </span><span class="c4">isNew = true</span><span class="c1 c0">&nbsp;for these three to support the upsampling operation to be implemented in Task 6.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 853.05px; height: 662.82px;"><img alt="" src="images/image22.jpg" style="width: 853.05px; height: 662.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1 c0"></span></p><p class="c3"><span class="c5">Unmodified Teapot&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmodified Teapot (Smooth)</span></p><h2 class="c18 c7" id="h.3su4pte32v7h"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 422.40px; height: 303.07px;"><img alt="" src="images/image3.png" style="width: 422.40px; height: 303.07px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 423.73px; height: 303.36px;"><img alt="" src="images/image6.png" style="width: 423.73px; height: 303.36px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></h2><p class="c3"><span class="c1 c5">Teapot with Splits Only&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Teapot with Splits Only (Smooth)</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 422.40px; height: 301.99px;"><img alt="" src="images/image11.png" style="width: 422.40px; height: 301.99px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 422.40px; height: 302.26px;"><img alt="" src="images/image29.png" style="width: 422.40px; height: 302.26px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c5">Teapot with Splits and Flips&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Teapots with Splits and Flips (Smooth)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 422.40px; height: 302.39px;"><img alt="" src="images/image5.png" style="width: 422.40px; height: 302.39px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 422.40px; height: 302.39px;"><img alt="" src="images/image2.png" style="width: 422.40px; height: 302.39px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h3 class="c3 c7" id="h.8xl0657tlbqo"><span class="c1 c5">Debugging</span></h3><p class="c3"><span class="c1 c0">Looking at the image with the teapots with splits and flips while having vertex-normal shading turned on, we see that a hole has been made in the teapot. We thoroughly looked into this and found out the sequence of splits and flips that lead to this. It happens when we perform a split on an edge and then flip one of the small edges. Let&rsquo;s take a look:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 365.50px; height: 250.87px;"><img alt="" src="images/image23.png" style="width: 365.50px; height: 250.87px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 369.50px; height: 223.86px;"><img alt="" src="images/image26.png" style="width: 369.50px; height: 223.86px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1 c0">This occurs when the two triangles involved in the flip have edges that are in line with each other, meaning there&rsquo;s an edge splitting them. This causes the flip to collapse the flipped edge onto the two edges that were in line, creating the illusion that the face and edge disappeared altogether. This is correct behavior for an edge flip in this situation. However, this creates a problem for vertex-normal shading, as we rely on the area of the faces:</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 576.00px; height: 387.20px;"><img alt="" src="images/image4.png" style="width: 576.00px; height: 387.20px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c0">After thinking about it and looking deeper at the code, we realized this could occur because a face is now &ldquo;nonexistent&rdquo;. Remember the edge that collapsed onto another edge? Well the mesh still thinks that&rsquo;s a face, but technically it&rsquo;s just a line now, so the normal is undefined and taking it yields NaN. We accounted for this by modifying our Task 3 code so that if the normal we calculate is NaN, we simply skip the face when calculating the average weighted normal. In C++, a float </span><span class="c4">f</span><span class="c0">&nbsp;is NaN if </span><span class="c4">f != f</span><span class="c1 c0">&nbsp;is true.</span></p><p class="c3"><span class="c1 c0">After some more playing around, we found other random unique combinations that trigger a similar effect, where triangles are undefined in the mesh. We realized that there is the potential for the area to be NaN too, so we also skip faces where the area turns out to be NaN.</span></p><p class="c3"><span class="c1 c0">Applying these two modifications to Task 3 eliminated this shading error!</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 658.50px; height: 471.51px;"><img alt="" src="images/image24.png" style="width: 658.50px; height: 471.51px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h2 class="c19 c7" id="h.hs1937hq6q77"><span class="c1 c9">Task 6 - Loop Subdivision for Mesh Upsampling</span></h2><p class="c3"><span class="c0">The comments in the skeleton code were a major help. Following step 1, we use loop subdivision to calculate the new positions of our existing vertices. However, if we come across a vertex that is on a boundary, we do not apply loop subdivision to it and instead copy its current position into its new position field. During this step, we also mark all the vertices we&rsquo;ve traversed as old vertices by setting their </span><span class="c6">isNew = false</span><span class="c1 c0">. This is used when determining which edges to flip later on. It is also important that we do not actually update the position of these vertices to their new positions. That will be done at the last step, step 5.</span></p><p class="c2"><span class="c1 c0"></span></p><p class="c3"><span class="c0">For step 2, we will temporarily store the new position of NEW vertices in the </span><span class="c6">newPosition</span><span class="c0">&nbsp;field of existing edges. This is because calculating the new vertices&rsquo; new positions while doing subdivision is hard. But since every old edge (excluding boundary edges) will be split, there will be as many NEW vertices as there are OLD non-boundary edges, so storing the NEW vertices&rsquo; new positions in their associated edges seems like a logical choice. Skipping over boundary edges, we toggle each edge we traverse&rsquo;s </span><span class="c6">isNew = false</span><span class="c1 c0">&nbsp;and calculate and save the result of loop subdivision in the edges.</span></p><p class="c2"><span class="c1 c0"></span></p><p class="c3"><span class="c0">For step 3, we loop over the OLD non-boundary edges, splitting them as we go. Whenever an edge is split, a NEW vertex is created at the midpoint of the original edge, the original edge is now 2 edges, and two more edges are created with endpoints at the new vertex and vertex opposite to it. We should only set the latter edges to </span><span class="c6">isNew = true</span><span class="c0">, this is because the 2 edges that are formed from the original edge are still considered part of the original mesh. In this step, we also copy the </span><span class="c6">newPosition</span><span class="c0">&nbsp;from the original edge into the </span><span class="c6">newPosition</span><span class="c1 c0">&nbsp;of NEW vertex. For every OLD non-boundary edge, 3 more NEW edges are created. And, the number of non-boundary vertices has doubled.</span></p><p class="c2"><span class="c1 c0"></span></p><h3 class="c3 c7" id="h.hsw4v9jwlvmx"><span class="c1 c5">Bug Encountered</span></h3><p class="c3"><span class="c0">There was a problem of running into an infinite loop when I was looping through the list of Edges in </span><span class="c6">mesh.edges</span><span class="c0">. I suspect that splitting edges has created new edges that extend the total length of the list, but that doesn&rsquo;t explain the infinite as the total number of edges created is finite. I added a statement to skip over an edge whose </span><span class="c6">isNew == true</span><span class="c0">, but I was still getting the infinite loop. So, I exploited a property of the list inserts whenever a new edge is created. Since newly created edges are appended to the end of the list, as soon as we arrive at an edge whose </span><span class="c6">isNew == true</span><span class="c1 c0">, we break out of the loop immediately, and we would have only split all the old edges.</span></p><p class="c2"><span class="c1 c0"></span></p><p class="c3"><span class="c0">Step 4 is flipping all the NEW edges that connect to an OLD vertex and a NEW vertex. This comes down to flipping 1 of the 3 NEW edges in every triangle that has gone through subdivision. Just a pattern I&rsquo;ve noticed. The </span><span class="c4">isNew</span><span class="c0">&nbsp;field can be accessed by traversing the two </span><span class="c0">halfedges</span><span class="c0">&nbsp;of the edge, then accessing the vertices associated with those </span><span class="c0">halfedges</span><span class="c0">. Leveraging the XOR operand (^), I was able to shorten the expression </span><span class="c6">(v0 &amp;&amp; !v1) || (!v0 &amp;&amp; v1)</span><span class="c1 c0">&nbsp;down a lot.</span></p><p class="c2"><span class="c1 c0"></span></p><p class="c3"><span class="c0">Step 5, the </span><span class="c6">newPosition</span><span class="c0">&nbsp;of every vertex has already been updated to contain their new positions. Copy </span><span class="c6">newPosition</span><span class="c0">&nbsp;into </span><span class="c6">position</span><span class="c0">&nbsp;to finalize the vertices&rsquo; positions when looping through </span><span class="c6">mesh.vertices</span><span class="c1 c0">.</span></p><p class="c2"><span class="c1 c0"></span></p><h3 class="c3 c7" id="h.n13d4qd2s372"><span>Sharp Corners and Edges</span></h3><p class="c3"><span class="c0">In the following four images, you can see that sharp corners and edges get gradually smoothed out the more times upsampling is done. This is because Loop subdivision changes the positions of original vertices to become a weighted sum of the vertex&rsquo;s neighboring vertices.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 216.00px; height: 152.14px;"><img alt="" src="images/image9.png" style="width: 216.00px; height: 152.14px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 216.00px; height: 152.28px;"><img alt="" src="images/image8.png" style="width: 216.00px; height: 152.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 216.00px; height: 152.14px;"><img alt="" src="images/image32.png" style="width: 216.00px; height: 152.14px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 216.00px; height: 152.28px;"><img alt="" src="images/image12.png" style="width: 216.00px; height: 152.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1 c0">To make edges more pronounced, we can subdivide closer and closer to the sharp edge. This creates neighboring vertices closer to the vertex at the sharp corner/edge, decreasing Loop subdivision&rsquo;s effects.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 303.26px;"><img alt="" src="images/image7.png" style="width: 432.00px; height: 303.26px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 305.55px;"><img alt="" src="images/image17.png" style="width: 432.00px; height: 305.55px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1 c0"></span></p><h3 class="c3 c7" id="h.kwrcysa418p2"><span>Asymmetry</span></h3><p class="c3"><span class="c0">Asymmetry during upsampling is caused by the inherent t</span><span class="c1 c0">opology of the geometry. Loop subdivision modifies the positions of vertices based on their neighbors.</span></p><p class="c3"><span class="c1 c0">Smooth-edged cube (symmetric) is generated by splitting every diagonal edge that goes across the face of the cube. This creates an X on each face, which is symmetric about the reflection of every planar cut through two opposing vertices or midpoints of edges.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 290.52px;"><img alt="" src="images/image13.png" style="width: 432.00px; height: 290.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 290.52px;"><img alt="" src="images/image28.png" style="width: 432.00px; height: 290.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c3"><span class="c1 c0">Tetrahedron is generated by flipping the diagonal edges so that 2 opposing vertices at the top face of the cube and 2 opposing vertices on the bottom face but rotated 90 degrees have degrees of 6; and the four other vertices have degrees of 3. It is rotationally symmetric about the center point and 109.5 degrees like an Ammonium molecule.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 306.72px;"><img alt="" src="images/image19.png" style="width: 432.00px; height: 306.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 305.64px;"><img alt="" src="images/image16.png" style="width: 432.00px; height: 305.64px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c1 c0"></span></p><h3 class="c3 c7" id="h.1hygt8pmhvbg"><span class="c1 c5">Boundary Exclusion Bug</span></h3><p class="c3"><span class="c1 c0">If we did not skip over boundary vertices when performing step 1, performing upsampling on /dae/beetle.dae (Left Image) will result in the image on the right. Not good.</span></p><p class="c3"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 308.03px;"><img alt="" src="images/image15.png" style="width: 432.00px; height: 308.03px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 432.00px; height: 307.10px;"><img alt="" src="images/image10.png" style="width: 432.00px; height: 307.10px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></body></html>