<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=r3oQQBWBLofdqMg7Xagtphmx_9IXfkwuEX_E26t7NMz0vzZTLk4Jh8uoFf3Lfl2HWUfeBmnvNOKGBKzuaehVvgloaAQohEkhRDaJfjGVnRI);.lst-kix_8wup04gzhtob-5>li{counter-increment:lst-ctn-kix_8wup04gzhtob-5}.lst-kix_207k7o1r4gx-2>li:before{content:"\0025a0   "}ol.lst-kix_8wup04gzhtob-7.start{counter-reset:lst-ctn-kix_8wup04gzhtob-7 0}.lst-kix_207k7o1r4gx-0>li:before{content:"\0025cf   "}.lst-kix_207k7o1r4gx-4>li:before{content:"\0025cb   "}.lst-kix_207k7o1r4gx-1>li:before{content:"\0025cb   "}.lst-kix_207k7o1r4gx-5>li:before{content:"\0025a0   "}ol.lst-kix_8wup04gzhtob-0.start{counter-reset:lst-ctn-kix_8wup04gzhtob-0 0}ol.lst-kix_8wup04gzhtob-4.start{counter-reset:lst-ctn-kix_8wup04gzhtob-4 0}.lst-kix_207k7o1r4gx-3>li:before{content:"\0025cf   "}ul.lst-kix_207k7o1r4gx-1{list-style-type:none}ul.lst-kix_207k7o1r4gx-2{list-style-type:none}ul.lst-kix_207k7o1r4gx-0{list-style-type:none}ul.lst-kix_207k7o1r4gx-5{list-style-type:none}.lst-kix_207k7o1r4gx-8>li:before{content:"\0025a0   "}ul.lst-kix_207k7o1r4gx-6{list-style-type:none}ul.lst-kix_207k7o1r4gx-3{list-style-type:none}ul.lst-kix_207k7o1r4gx-4{list-style-type:none}.lst-kix_207k7o1r4gx-6>li:before{content:"\0025cf   "}ul.lst-kix_207k7o1r4gx-7{list-style-type:none}ul.lst-kix_207k7o1r4gx-8{list-style-type:none}.lst-kix_207k7o1r4gx-7>li:before{content:"\0025cb   "}ol.lst-kix_8wup04gzhtob-8.start{counter-reset:lst-ctn-kix_8wup04gzhtob-8 0}.lst-kix_8wup04gzhtob-4>li{counter-increment:lst-ctn-kix_8wup04gzhtob-4}.lst-kix_8wup04gzhtob-7>li{counter-increment:lst-ctn-kix_8wup04gzhtob-7}ol.lst-kix_8wup04gzhtob-5.start{counter-reset:lst-ctn-kix_8wup04gzhtob-5 0}ol.lst-kix_8wup04gzhtob-2.start{counter-reset:lst-ctn-kix_8wup04gzhtob-2 0}.lst-kix_8wup04gzhtob-6>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-6,decimal) ". "}.lst-kix_8wup04gzhtob-2>li{counter-increment:lst-ctn-kix_8wup04gzhtob-2}.lst-kix_8wup04gzhtob-8>li{counter-increment:lst-ctn-kix_8wup04gzhtob-8}.lst-kix_8wup04gzhtob-4>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-4,lower-latin) ". "}.lst-kix_8wup04gzhtob-8>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-8,lower-roman) ". "}ol.lst-kix_8wup04gzhtob-8{list-style-type:none}ol.lst-kix_8wup04gzhtob-7{list-style-type:none}.lst-kix_8wup04gzhtob-5>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-5,lower-roman) ". "}.lst-kix_8wup04gzhtob-7>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-7,lower-latin) ". "}ol.lst-kix_8wup04gzhtob-4{list-style-type:none}.lst-kix_8wup04gzhtob-1>li{counter-increment:lst-ctn-kix_8wup04gzhtob-1}ol.lst-kix_8wup04gzhtob-3{list-style-type:none}ol.lst-kix_8wup04gzhtob-6.start{counter-reset:lst-ctn-kix_8wup04gzhtob-6 0}ol.lst-kix_8wup04gzhtob-6{list-style-type:none}ol.lst-kix_8wup04gzhtob-5{list-style-type:none}ol.lst-kix_8wup04gzhtob-0{list-style-type:none}ol.lst-kix_8wup04gzhtob-2{list-style-type:none}ol.lst-kix_8wup04gzhtob-1{list-style-type:none}ol.lst-kix_8wup04gzhtob-1.start{counter-reset:lst-ctn-kix_8wup04gzhtob-1 0}ol.lst-kix_8wup04gzhtob-3.start{counter-reset:lst-ctn-kix_8wup04gzhtob-3 0}.lst-kix_8wup04gzhtob-0>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-0,decimal) ". "}.lst-kix_8wup04gzhtob-0>li{counter-increment:lst-ctn-kix_8wup04gzhtob-0}.lst-kix_8wup04gzhtob-1>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-1,lower-latin) ". "}.lst-kix_8wup04gzhtob-6>li{counter-increment:lst-ctn-kix_8wup04gzhtob-6}.lst-kix_8wup04gzhtob-2>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-2,lower-roman) ". "}.lst-kix_8wup04gzhtob-3>li{counter-increment:lst-ctn-kix_8wup04gzhtob-3}.lst-kix_8wup04gzhtob-3>li:before{content:"" counter(lst-ctn-kix_8wup04gzhtob-3,decimal) ". "}ol{margin:0;padding:0}table td,table th{padding:0}.c29{border-right-style:solid;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:45pt;border-top-color:#000000;border-bottom-style:solid}.c2{border-right-style:solid;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:216pt;border-top-color:#000000;border-bottom-style:solid}.c25{border-right-style:solid;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:middle;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:45pt;border-top-color:#000000;border-bottom-style:solid}.c19{margin-left:-72pt;padding-top:18pt;padding-bottom:6pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c32{margin-left:-72pt;padding-top:0pt;padding-bottom:3pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c33{margin-left:-72pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center;margin-right:-72pt}.c5{margin-left:-72pt;padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c18{margin-left:-72pt;padding-top:0pt;padding-bottom:16pt;line-height:1.15;orphans:2;widows:2;text-align:left;margin-right:-72pt}.c1{color:#000000;font-weight:300;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Helvetica Neue";font-style:normal}.c0{color:#000000;font-weight:300;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Helvetica Neue";font-style:normal}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c37{color:#666666;text-decoration:none;vertical-align:baseline;font-size:15pt;font-style:normal}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c11{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c26{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c15{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c27{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c24{font-weight:400;font-size:11pt;font-family:"Arial"}.c34{background-color:#fafafa;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c7{font-size:12pt;font-family:"Roboto Mono";font-weight:300}.c30{color:#000000;text-decoration:none;vertical-align:baseline}.c3{font-weight:300;font-family:"Helvetica Neue"}.c6{font-weight:700;font-family:"Helvetica Neue"}.c9{font-weight:400;font-family:"Helvetica Neue"}.c31{color:inherit;text-decoration:inherit}.c21{font-family:"Courier New";font-weight:400}.c28{font-weight:400;font-family:"Arial"}.c35{text-indent:36pt}.c39{font-size:26pt}.c16{padding:5pt 5pt 5pt 5pt}.c8{vertical-align:sub}.c36{font-size:11pt}.c22{font-size:16pt}.c4{height:0pt}.c17{height:11pt}.c38{height:12pt}.c23{vertical-align:super}.c20{font-style:italic}.c13{page-break-after:avoid}.c10{font-size:12pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:0pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:0pt;font-family:"Helvetica Neue";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c34 doc-content"><p class="c5"><span>Webpage: </span><span class="c27"><a class="c31" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-d-and-j/hw3/index.html&amp;sa=D&amp;source=editors&amp;ust=1710743220040404&amp;usg=AOvVaw3A4zboGmMDNexw4TYXrzHy">https://cal-cs184-student.github.io/hw-webpages-sp24-d-and-j/hw3/index.html</a></span><span class="c11 c24">&nbsp;</span></p><p class="c13 c32 title" id="h.ynuhj7g8d1"><span class="c11 c9 c39">HW3: Pathtracer</span></p><p class="c13 c18 subtitle" id="h.b0gs0jwziuy2"><span class="c9 c37">By: Joseph Liu and Daniel Hsu</span></p><h2 class="c19 c13" id="h.mwv03lp04h8y"><span class="c11 c9 c22">Overview</span></h2><p class="c5"><span class="c0">In this project, we implemented the various components of a Monte Carlo path tracing renderer to render realistic 3D scenes. First we implemented ray generation for a camera, which takes in sensor sample coordinate and generates a ray in world space by mapping the sensor sample from image space to camera space and transforming this vector to world space to create the ray. Then we implemented pixel ray tracing, which calculates the color of a pixel at a given x-y-coordinate by averaging the colors obtained from tracing and sampling multiple rays through scene, each with a random offset for anti-aliasing. With ray-generation and ray-sampling in place, we then implemented ray-triangle intersection, which checks of a ray intersects a triangle using barycentric coordinates, similarly to Homework 1. </span></p><p class="c5"><span class="c0">However, naively checking each triangle in the mesh for a collision per every ray we cast is very expensive, so we implemented the Bounding Box Hierarchy optimization, which speeds up ray intersection tests by only testing for ray-intersection with objects in the bounding box that a ray intersects. This is done by having a tree of bounding boxes as inner nodes that get smaller and smaller until a threshold of objects is reached, in which leaf nodes containing primitives are created. Now, instead of checking for ray intersection with each object, we check ray-intersection with the bounding boxes until we hit a leaf node, where we then test intersection of the ray for each primitive in the leaf. The logic is, if it doesn&rsquo;t hit the root, it won&rsquo;t hit the children either, so don&rsquo;t bother testing object by object.</span></p><p class="c5"><span class="c0">With an efficient ray-tracing and ray-intersection infrastructure in place, we move on to lighting. First we implement direct lighting, in which we get the zero-bounce and one-bounce radiance. Zero-bounce radiance is just light from the light source with no bounces, so we just return the emission of the intersected object&rsquo;s BSDF. As for one-bounce radiance, we implemented two approaches: hemisphere sampling and importance sampling. Our hemisphere sampling function estimates direct lighting at a ray-object intersection point by uniformly sampling the hemisphere around the intersection normal. This is done by generating a number of sample rays, checking if they intersect with any objects in the scene, and if so, adding the light emitted by the intersected object to the total light output. Importance sampling on the other hand estimates direct lighting by sampling only from light sources in the scene. For each light, if it&rsquo;s a delta light, we sample it once, and if not, we sample multiple times. In both cases ,we check if the light is visible from the intersection point, and if so, we add the light&rsquo;s contribution to the total light output.</span></p><p class="c5"><span class="c0">Direct lighting shows us what the lights directly illuminate, but in real life, light bounces off objects in the scene to illuminate other parts of the scene as well, so we implement global illumination. We do this by calculating the radiance that comes from paths with at least one bounce. Specifically, for each ray cast into the scene, while the ray depth (number of bounces) is less than the maximum, we sample a new direction from the BSDF at the intersection point and create a new ray from the intersection point in the sampled direction to simulate a bounce. If this new ray intersects with an object in the scene, we recursively calculate the radiance along this ray and multiply it by the BSDF (albedo) value in the sampled direction.</span></p><p class="c5"><span class="c0">Finally, we implement adaptive sampling, which optimizes the sampling more in areas with high frequency color variation. We implement this by first generating a ray from the camera through a random point and estimating the radiance along this ray. We then add the estimated radiance to the total pixel irradiance and update the sums used to find the mean and variance. Once we sample enough samples, we calculate the tolerance using the mean and variance, and if the tolerance is less than or equal to the maximum allotted, we stop sampling the pixel and update the pixel color in the sample buffer with the average color of the samples taken so far.</span></p><h2 class="c19 c13" id="h.wh63r0p8b9li"><span class="c9">Part 1 - Ray </span><span class="c9 c22">Generation</span><span class="c11 c9 c22">&nbsp;and Scene Intersection</span></h2><h3 class="c5 c13" id="h.mubrf5h1cwvc"><span>Ray Generation</span></h3><p class="c5"><span class="c0">The first step of ray generation is translating a position in image space into normalized coordinates that the ray generation function can use. Given non-negative integers x and y, these can represent the bottom left coordinate of a pixel position. Adding a random positive offset (less than 1) to that (x, y) pair means we sample from a random position within that pixel. Divide the new x (x&rsquo;) by the screen width and the new y (y&rsquo;) by the screen height to normalize (x, y).</span></p><p class="c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 763.00px; height: 307.00px;"><img alt="" src="images/image45.png" style="width: 763.00px; height: 307.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c3 c10">Then, we create a ray that starts at the camera space&rsquo;s origin and extends through (x&rsquo;, y&rsquo;)&rsquo;s corresponding location in camera space. To do that, we find the </span><span class="c21 c10">xMin</span><span class="c3 c10">, </span><span class="c21 c10">yMin</span><span class="c3 c10">, </span><span class="c21 c10">xMax</span><span class="c3 c10">, and </span><span class="c10 c21">yMax</span><span class="c0">&nbsp;of the camera space. Then, the xy coordinate in camera space is a 2D lerp between the bounds of the camera space using x&rsquo; and y&rsquo; as the parameters for lerp. The z-position of all rays is -1.</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c3 c10">Now with our ray vector in camera space, we simply do a matrix vector multiplication with </span><span class="c21 c10">c2w</span><span class="c3 c10">&nbsp;to transform our vector in camera space into a vector in world space. Finally, normalize the final vector and set the ray&rsquo;s </span><span class="c21 c10">min_t</span><span class="c3 c10">&nbsp;and </span><span class="c21 c10">max_t</span><span class="c0">.</span></p><p class="c5 c17"><span class="c0"></span></p><h3 class="c5 c13" id="h.o0pkeroek3s9"><span>Triangle Intersection</span></h3><p class="c5"><span class="c0">We can use the Moller Trumbore algorithm to find the intersection, which is the optimized version of determining a sectioned plane-ray intersection. A triangle is just a region on a plane, so we can determine a triangle intersection with a plane intersection and use barycentric coordinates to determine if said intersection is within the triangle. A plane can be represented with a point on the plane and a normal vector that all points on the plane are orthogonal to. This means that a vector dot product of the normal and any other vector created from two points on the plane is 0.</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c3 c10">Now let&rsquo;s combine the ideas of plane-ray intersection and barycentric coordinates. The point of intersection can be represented with O + tD, where O is the origin of the ray, t is the time to intercept, and D is the normalized direction vector of the ray. It can also be represented with aP</span><span class="c3 c8">1</span><span class="c3">&nbsp;+ bP</span><span class="c3 c8">2</span><span class="c3">&nbsp;+ cP</span><span class="c3 c8">3</span><span class="c3">&nbsp;where P</span><span class="c3 c8">1</span><span class="c3">, P</span><span class="c3 c8">2</span><span class="c3">, and P</span><span class="c3 c8">3</span><span class="c3">&nbsp;are the 3 vertices of the triangle and a, b, and c are the barycentric parameters. However, when a point is inside the triangle, a = 1 - b - c and all three parameters are greater than or equal to 0. Each representation&rsquo;s dot product with the normal will yield 0, so we can place them on opposite sides of the equation of factor out the normal: </span><span class="c3 c10">O + tD = (1-b-c)P</span><span class="c3 c8">1</span><span class="c3">&nbsp;+ bP</span><span class="c3 c8">2</span><span class="c3">&nbsp;+ cP</span><span class="c3 c8">3</span><span class="c1">. After some refactoring of the unknown variables t, b, and c we arrive at the vector-matrix equation of the Moller Trumbore algorithm.</span></p><p class="c5 c17"><span class="c1"></span></p><p class="c5"><span class="c3">Once we have calculated t, b, and c, we know that the intersection is not within the triangle if b &lt; 0, c &lt; 0, OR 1-b-c &lt; 0. And, we know that the ray intersection is invisible to the camera if t &lt; r.min_t OR t &gt; r.max_t. If t is within range, update r.max_t to be the value of t. In one edge case though, our variables might be undefined if the ray is parallel to the triangle, meaning that they never make an intersection. So, we always return false if </span><span class="c21">dot(S1, E1)</span><span class="c3">&nbsp;in the algorithm equals 0. For </span><span class="c21">Triangle::intersect()</span><span class="c3">, we set the fields of </span><span class="c21">isect</span><span class="c3">&nbsp;to the correct values. As for </span><span class="c21">isect-&gt;n</span><span class="c1">, we use the barycentric equation to calculate the interpolated normal using the normals at each vertex (n1, n2, n3) and b and c.</span></p><p class="c5 c17"><span class="c1"></span></p><h3 class="c5 c13" id="h.ybmmfeqf1rlv"><span>Sphere Intersection</span></h3><p class="c5"><span class="c3 c10">For sphere-ray intersection, if there is an intersection, then the point of intersection, here denoted as (x,y,z), will satisfy the equation x</span><span class="c3 c23 c10">2</span><span class="c3 c10">+y</span><span class="c3 c23 c10">2</span><span class="c3 c10">+z</span><span class="c3 c23 c10">2</span><span class="c3 c10">=R</span><span class="c3 c23 c10">2</span><span class="c3 c10">&nbsp;where R is the radius of the sphere and the sphere is centered at (0,0,0). x</span><span class="c3 c23 c10">2</span><span class="c3 c10">+y</span><span class="c3 c23 c10">2</span><span class="c3 c10">+z</span><span class="c3 c10 c23">2</span><span class="c3 c10">&nbsp;is also the dot product of (x,y,z) with itself, which is also representable by (P - C) where P is the point of intersection and C is the center of the sphere. Once again, we represent P = O + tD to get (O + tD - C)</span><span class="c3 c23 c10">2</span><span class="c3 c10">&nbsp;- R</span><span class="c3 c23 c10">2</span><span class="c0">&nbsp;= 0. This is a quadratic function, so we can use the quadratic formula to solve it. Note that, however, the quadratic formula contains a square root, meaning that it cannot take in a negative number. If the number is negative, it means that there are no intersection points and we return false immediately. Also note that if the ray is tangent to the sphere, there is only 1 intersection and the square root result equals 0.</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c3 c10">Storing our results in t1 and t2 (</span><span class="c21 c10">t1 == t2</span><span class="c3 c10">&nbsp;if there is only 1 intersection), we find the minimum between t1 and t2 that lies within r.min_t and r.max_t. </span><span class="c3">If it is within range, update r.max_t to be its value. For </span><span class="c21">Sphere::intersect()</span><span class="c3">, update </span><span class="c21">i</span><span class="c3">&nbsp;as needed. For </span><span class="c21">i-&gt;n</span><span class="c1">, the normal at the intersection is simply the normalized vector from the sphere&rsquo;s center to the intersection point.</span></p><p class="c5 c17"><span class="c0"></span></p><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.0"></a><table class="c15"><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image44.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 422.40px; height: 316.80px;"><img alt="" src="images/image20.png" style="width: 422.40px; height: 316.80px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c5"><span class="c3">&nbsp;</span><span class="c11 c6 c36">Left Image: CBspheres.png; Right Image: banana.png; both rendered with normal shading.</span></p><p class="c5 c17"><span class="c0"></span></p><h2 class="c19 c13" id="h.zd0d4y2p947m"><span class="c9">Part 2 - Bounding </span><span class="c9 c22">Volume</span><span class="c11 c9 c22">&nbsp;Hierarchy</span></h2><h3 class="c5 c13" id="h.ukojgp6apyi6"><span>BVH Construction Algorithm</span></h3><p class="c5"><span class="c3 c10">Our BVH algorithm recursively creates smaller and smaller children bounding boxes until a child contains a maximum of </span><span class="c7">max_leaf_size</span><span class="c3 c10">&nbsp;primitives, in which it becomes a leaf. First, we set the bounding box to be one that encapsulates all the primitives between </span><span class="c7">start</span><span class="c3 c10">&nbsp;and </span><span class="c7">end</span><span class="c3 c10">. To split this bounding box, the heuristic we chose was to use the average of centroids along the longest axis as the split point. To find this, we get the dimensions of the bounding box and set the split axis to be the one corresponding to the largest dimension (</span><span class="c7">x</span><span class="c3 c10">, </span><span class="c7">y</span><span class="c3 c10">, or </span><span class="c7">z</span><span class="c3 c10">). Then we sort all the primitives in the bounding box based on the coordinate value of the axis. For example, if the split axis is the y-axis, then we sort the primitives based on the y-coordinate of their centroids. Next we split the primitives into two sets down the midpoint of the sorted list of primitives, and recursively run </span><span class="c7">construct_bvh</span><span class="c3 c10">&nbsp;on each half. This will create smaller and smaller bounding boxes. Finally, we turn our attention back to the bounding box at hand, where all that&rsquo;s left to do is to create a new </span><span class="c7">BVHNode</span><span class="c0">&nbsp;and set its left and right children to the return value of the recursive calls, and return this node. </span></p><p class="c5 c17"><span class="c0"></span></p><h3 class="c5 c13" id="h.3qyhce781lhc"><span class="c11 c6 c10">Images</span></h3><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 658.45px; height: 492.28px;"><img alt="" src="images/image13.png" style="width: 658.45px; height: 492.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c6 c20 c10">dae/sky/CBlucy.dae</span></p><p class="c5"><span class="c11 c6 c10">No BVH: 1452.50s</span></p><p class="c5"><span class="c11 c6 c10">BVH: 1.20s</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 658.56px; height: 493.92px;"><img alt="" src="images/image3.png" style="width: 658.56px; height: 493.92px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c6 c10 c20">dae/sky/dragon.dae</span></p><p class="c5"><span class="c11 c6 c10">No BVH: 1189.96s</span></p><p class="c5"><span class="c11 c6 c10">BVH: 1.06s</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 658.56px; height: 493.92px;"><img alt="" src="images/image33.png" style="width: 658.56px; height: 493.92px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c30 c6 c20 c10">dae/sky/wall-e.dae</span></p><p class="c5"><span class="c11 c6 c10">No BVH: 2830.06s</span></p><p class="c5"><span class="c11 c6 c10">BVH: 1.96s</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 658.56px; height: 493.92px;"><img alt="" src="images/image21.png" style="width: 658.56px; height: 493.92px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c5"><span class="c6 c20 c10">dae/sky/blob.dae</span></p><p class="c5"><span class="c11 c6 c10">No BVH: 2246.83s</span></p><p class="c5"><span class="c6 c10">BVH: 1.74s</span></p><p class="c5 c17"><span class="c0"></span></p><h3 class="c5 c13" id="h.q3pm9ng03y9"><span>Rendering Time Comparison</span></h3><p class="c5"><span class="c3 c10">With the BVH optimization, we found significant speedup in rendering the models. Especially for the very large ones, this difference was significant (with an average 1267x speedup). For each of the images above (</span><span class="c3 c20 c10">CBlucy.dae, dragon.dae, wall-e.dae, </span><span class="c3 c10">and</span><span class="c3 c20 c10">&nbsp;blob.dae</span><span class="c3 c10">), we found that without BVH, they would take well above 1000 seconds to render, whereas with the BVH optimization, they took no more than 2 seconds to render. The exact times are quoted in the </span><span class="c3 c10 c27"><a class="c31" href="#h.3qyhce781lhc">images section</a></span><span class="c0">. This is because with BVH, we are greatly reducing the amount of ray-primitive intersection tests because of the way the BVH tree is built. The logic is, if it doesn&rsquo;t hit the root, it won&rsquo;t hit the children either, so don&rsquo;t bother testing object by object. Essentially, we only check ray-primitive intersections for objects that are in the leaf node of the BVH that got intersected by the ray. Without BVH, the naive approach is to have each ray would be tested against every object in the scene to find out if they intersect, which is a lot less efficient.</span></p><h2 class="c19 c13" id="h.ppvjqtsnekc8"><span class="c9">Part 3</span><span class="c9">&nbsp;- Direct Illumination</span></h2><h3 class="c5 c13" id="h.234jyo2dam7q"><span class="c11 c6 c10">Implementation: Direct Lighting Hemisphere Sampling</span></h3><p class="c5"><span class="c3 c10">This implementation of direct lighting estimates the direct lighting by sampling uniformly in a hemisphere centered at the intersection point </span><span class="c7">hit_p</span><span class="c3 c10">&nbsp;and given the direction from which the ray came </span><span class="c7">w_out</span><span class="c3 c10">. We define </span><span class="c7">L_out</span><span class="c3 c10">&nbsp;to hold the total estimated lighting and sample </span><span class="c7">ns_area_light</span><span class="c0">&nbsp;times for every light source. For each sample, we generate a new ray in the sampled direction and check if it intersects with any object in the scene. If it does, we calculate the contribution of the intersected object&rsquo;s emission to the total lighting at the intersection point, which is (BSDF at hit_p) * (emission of intersected object) * (cosine of the angle between sampled direction and normal at the intersection point) / (the number of samples). </span></p><h3 class="c5 c13 c38" id="h.4uavg33vr2pe"><span class="c11 c6 c10"></span></h3><h3 class="c5 c13" id="h.fjkzzverqakb"><span class="c11 c6 c10">Implementation: Direct Lighting Importance Sampling</span></h3><p class="c5"><span class="c3 c10">For this implementation, instead of sampling uniformly in a hemisphere, we sample only from the light sources. Similar to hemisphere sampling, we define an intersection point </span><span class="c7">hit_p</span><span class="c3 c10">&nbsp;and the direction from which the ray came </span><span class="c7">w_out</span><span class="c3 c10">, as well as </span><span class="c7">L_out</span><span class="c0">&nbsp;to hold the estimated lighting. For each light in the scene, we sample a direction toward the light nad calculate the distribution of the light to the total lighting at the intersection point. </span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c0">If the light is a delta light, which is one that emits light in a single direction, then we sample it just once. We then sample a direction toward the light source and check if it&rsquo;s visible from the hit point. If it is, then we generate a shadow ray toward the light. If the shadow ray doesn&rsquo;t interset anything, we add the contribution to the L_out:</span></p><p class="c33"><span class="c11 c7">(BSDF at hit_p) * (light sample) * w_in.z / pdf</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c3 c10">If the light is not a delta light, then we sample it ns_area_light times. We keep a running sum </span><span class="c7">running_sum</span><span class="c3 c10">&nbsp;to hold the sum of the contributions of all the samples. For each sample, if the light is visible from the hit point, we once again generate a shadow ray toward the light. If the shadow ray doesn&rsquo;t intersect with any object in the scene, we calculate the contribution of the light to the total lighting at the intersection point and add it to </span><span class="c7">running_sum</span><span class="c3 c10">. Finally, we average out the samples by dividing </span><span class="c7">running_sum</span><span class="c0">&nbsp;by the total number of samples.</span></p><p class="c5 c17"><span class="c0"></span></p><h3 class="c5 c13" id="h.cplekyz52yt"><span>Images</span></h3><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.1"></a><table class="c15"><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 359.44px;"><img alt="" src="images/image24.png" style="width: 480.00px; height: 359.44px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 359.44px;"><img alt="" src="images/image5.png" style="width: 480.00px; height: 359.44px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c3">&nbsp;</span><span class="c6">Left Image: </span><span class="c6 c20">dae/sky/CBbunny.dae</span><span class="c11 c6 c36">&nbsp;rendered with Hemisphere sampling; Right Image: Same dae, rendered with Lighting Importance Sampling. Both with 64 samples per pixel and 32 light rays.</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c0">When the number of light rays per pixel increases for Lighting Importance Sampling, the noise levels in soft shadows decrease.</span></p><p class="c5 c17"><span class="c0"></span></p><a id="t.34c968869fbbdaac8fff0fec79919d98042a1192"></a><a id="t.2"></a><table class="c15"><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 361.09px;"><img alt="" src="images/image36.png" style="width: 480.00px; height: 361.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 361.09px;"><img alt="" src="images/image32.png" style="width: 480.00px; height: 361.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 361.09px;"><img alt="" src="images/image14.png" style="width: 480.00px; height: 361.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 361.09px;"><img alt="" src="images/image8.png" style="width: 480.00px; height: 361.09px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c5"><span class="c6 c10">From top to down, left to right, </span><span class="c6 c20 c10">dae/keenan/banana.dae</span><span class="c6 c10">&nbsp;rendered with Light Importance Sampling at 1 sample per pixel but 1, 4, 16, 64 light rays.</span></p><p class="c5 c17"><span class="c0"></span></p><h3 class="c5 c13" id="h.8kruxbcfehqe"><span class="c11 c6 c10">Uniform Hemisphere Sampling vs. Lighting Sampling</span></h3><p class="c5"><span class="c0">With not a lot of light sources, Lighting sampling fairs better than Hemisphere sampling. With Hemisphere sampling, we are sampling randomly within a hemisphere, which has a chance of not hitting a light source with a ray even when (from a qualitative perspective) we can see the light source casting directly onto an object&rsquo;s surface. When that location on the surface does not detect any light, it contributes a black pixel to the sampling equation. Other times, hemisphere sampling hits the light source quite often, which generates a brighter pixel. When dark and bright pixels are closely next to each other in an image, they show clear signs of noise. Lighting sampling does not have as big an issue regarding noise as hemisphere sampling does. This is because rays always cast to some location on a light source, so with enough sampling, it converges a lot faster than Hemisphere.</span></p><p class="c5 c17"><span class="c0"></span></p><h3 class="c5 c13" id="h.odz306min2cc"><span class="c11 c6 c10">Debugging</span></h3><p class="c5"><span class="c3 c10">We noticed that our renders for importance sampling were turning out dimmer than expected. To debug this, we played around with the </span><span class="c7">EPS_F</span><span class="c3 c10">&nbsp;vs. </span><span class="c7">EPS_D</span><span class="c3 c10">&nbsp;values. We found that using </span><span class="c7">EPS_D</span><span class="c3 c10">&nbsp;instead of </span><span class="c7">EPS_F</span><span class="c0">&nbsp;solve the issue to some extent, but it was still dimmer than the spec and the shadow was a little off. With some research and consultation from Ed, we discovered this might be due to a phenomenon called self-shadowing, in which a surface incorrectly casts a shadow on itself due to numerical precision errors in the calculations. To solve this issue, we added the following two lines of code to our shadow ray code:</span></p><p class="c5 c35"><span class="c11 c7">shadow_ray.min_t = EPS_F;</span></p><p class="c5 c35"><span class="c11 c7">shadow_ray.max_t = distToLight - EPS_F;</span></p><p class="c5"><span class="c3 c10">Setting the shadow ray&rsquo;s </span><span class="c7">min_t</span><span class="c3 c10">&nbsp;to </span><span class="c7">EPS_F</span><span class="c0">&nbsp;ensures that the shadow ray starts a tiny bit above the surface from which it was being cast. This helps avoid self-intersections where the ray might incorrectly detect an intersection with the surface it started from.</span></p><p class="c5"><span class="c3 c10">Setting the shadow ray&rsquo;s </span><span class="c7">max_t</span><span class="c3 c10">&nbsp;to </span><span class="c7">distToLight - EPS_F</span><span class="c0">&nbsp;ensures that the shadow ray doesn&rsquo;t extend beyond the light source, but rather stops just before reaching the light. THis helps avoid situations where the ray may incorrectly intersect other surfaces beyond the light source, causing those surfaces to cast a shadow and dim the light.</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5 c17"><span class="c0"></span></p><h2 class="c13 c19" id="h.4gw8wxib6gry"><span class="c11 c9 c22">Part 4 - Global Illumination</span></h2><h3 class="c5 c13" id="h.kcc2j0dlca2c"><span class="c11 c6 c10">Implementation: Indirect Lighting</span></h3><p class="c5"><span class="c0">The indirect lighting function at_least_one_bounce_radiance() calculates the radiance that reaches a point in the scene after at least one bounce off a surface. For our implementation, we first sample a new direction from the BSDF at the intersection point. Then, if the maximum ray depth has been reached, then we simply return; if not, then we generate a new ray in the sampled direction and recursively call the function with this new ray. We also use a Russian Roulette termination scheme, where we terminate the recursion with some probability. We chose 0.35 for our termination probability. Finally, we add the radiance returned by the recursive call to the total radiance and weigh it by the value of the BSDF, the cosine of the angle between the new direction and surface normal, as well as the inverse of the PDF.</span></p><p class="c5 c17"><span class="c0"></span></p><h3 class="c5 c13" id="h.az0ldq4t7r97"><span class="c11 c6 c10">Images</span></h3><p class="c5"><span class="c6 c10">Some images rendered with global illumination.</span></p><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.3"></a><table class="c15"><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image28.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image18.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c6 c10">Left: </span><span class="c6 c20 c10">dae/sky/CBbunny.dae</span><span class="c6 c10">&nbsp;rendered with only direct lighting. Right: </span><span class="c6 c20 c10">dae/sky/CBbunny.dae</span><span class="c6 c10">&nbsp;rendered with only indirect lighting.</span></p><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.4"></a><table class="c15"><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image5.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image40.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c5 c17"><span class="c0"></span></p><p class="c5 c17"><span class="c0"></span></p><a id="t.3845c452a510642c8644cd9a10926eb6370931f4"></a><a id="t.5"></a><table class="c15"><tr class="c4"><td class="c16 c29" colspan="1" rowspan="1"><p class="c12"><span class="c11 c6 c10">Max Ray Depth</span></p></td><td class="c2 c16" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">No accumulation</span></p></td><td class="c2 c16" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">Accumulation</span></p></td><td class="c2 c16" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">Accumulation + RR</span></p></td></tr><tr class="c4"><td class="c25 c16" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">0</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image2.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image10.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image39.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c4"><td class="c25 c16" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">1</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image38.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image42.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image37.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c4"><td class="c25 c16" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">2</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image19.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image9.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image17.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c4"><td class="c25 c16" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">3</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image35.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image31.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image4.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c4"><td class="c16 c25" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">4</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image27.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image43.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image6.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c4"><td class="c25 c16" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">5</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image11.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image23.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12 c17"><span class="c0"></span></p></td></tr><tr class="c4"><td class="c25 c16" colspan="1" rowspan="1"><p class="c26"><span class="c11 c6 c10">100</span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12 c17"><span class="c0"></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12 c17"><span class="c0"></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image15.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c5"><span class="c30 c3 c20 c10">Non-Accumulated Versions</span></p><p class="c5"><span class="c0">As we can see in the No Accumulation column, the 2nd bounce adds light that bounced off the walls/floor and hit the bunny or that bounced off the bunny and hit the walls/floor. In either case, small lighting contributions are added. We can see that the bottom of the bunny is now slightly illuminated, which comes from the light that bounces off the floor/wall and hits the bottom of the bunny; since the 1st bounce is just light-&gt;object-&gt;camera, we wouldn&rsquo;t see it if we don&rsquo;t go past 1 bounce. If we look at the image where we don&rsquo;t accumulate, we see that this only includes parts of the bunny that didn&rsquo;t get light from the first bounce. As for third bounce, we see a very dim but slightly recognizable view of the box. So we see that the third bounce is contributes just general environment lighting to the scene.</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c3 c20 c10 c30">Accumulated Versions</span></p><p class="c5"><span class="c0">Moving on to the renders of the bunny where we accumulate the multiple bounces of light, we first see that trivially, with max-depth of 0, we only see the light, since this is zero-bounce. For one bounce, we see only the parts of the scene directly hit by the light, and observe that the shadows are very dark since they are not illuminated at all by the light. Beyond one-bounce, we see the shadows and non-directly illuminated parts of the scene become a slight more lit, which is representative of what we realistically would see. Additionally, we start to see the color of the walls reflected off the bunny, meaning that the light is hitting the wall, becoming tinted with the color of the wall, then hitting the bunny. Beyond 3 bounces, we see less and less of an improvement other than the scene becoming more bright and a slight more detail on the rabbit (bumps and whatnot) becoming more apparent.</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c3 c20 c10">Russian Roulette</span></p><p class="c5"><span class="c0">Between using Russian Roulette termination and not, we observe little to no difference. We chose a termination probability of 0.35, since it was between the recommended 0.3 and 0.4, and observed that it produced results very similar to if we didn&rsquo;t use Russian Roulette at all. The difference is only really apparent if we zoom in a lot, where we see that the Russian Roulette version looks a slight bit more grainy.</span></p><p class="c5 c17"><span class="c0"></span></p><p class="c5"><span class="c6 c10">The following images are </span><span class="c6 c20 c10">dae/keenan/banana.dae</span><span class="c6 c10">&nbsp;files rendered with 4 light rays per light, a max depth of 5, and the number of samples per pixel being 1, 2, 4, 8, 16, 64, and 1024 respectively going from left to right, top to bottom. As the number of samples increases, the noise levels of the image decreases.</span></p><a id="t.3c54b84d4b719ac14bf36c1accd15d1076e496e8"></a><a id="t.6"></a><table class="c15"><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image7.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image34.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image16.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image26.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image1.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image41.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image22.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14 c17"><span class="c0"></span></p></td></tr></table><p class="c5 c17"><span class="c0"></span></p><p class="c5 c17"><span class="c0"></span></p><h2 class="c19 c13" id="h.hs1937hq6q77"><span class="c11 c9 c22">Part 5 - Adaptive Sampling</span></h2><h3 class="c5 c13" id="h.t3sutvlbjb7b"><span class="c11 c6 c10">Implementation: Adaptive Sampling</span></h3><p class="c5"><span class="c0">Adaptive sampling is used in ray tracing to reduce noise in the final image while also optimizing the number of rays traced. This is done by tracing more rays in areas of the image where the color varies greatly and fewer in areas where the color is more uniform.</span></p><p class="c5"><span class="c3 c10">We first defined the number of samples to evaluate as </span><span class="c7">ns_aa</span><span class="c0">, the origin pixel, and the total color of the pixel, which will be aggregated. </span></p><p class="c5"><span class="c3 c10">If the number of samples per pixel is 1, we simply generate a single ray through the pixel and estimate the radiance using </span><span class="c7">est_radiance_global_illumination</span><span class="c0">. </span></p><p class="c5"><span class="c3 c10">Otherwise, we initialize the sums </span><span class="c7">s1</span><span class="c3 c10">&nbsp;and </span><span class="c7">s2</span><span class="c3 c10">&nbsp;used to calculate the variance, the sample count (number of samples taken), and a flag indicating whether the sampling is done. Then, we generate a batch of rays per pixel. For each ray, we generate a random sample point within the pixel as well as a ray through the sample point. THen we estimate the radiance along this ray and add it to the total color as well as </span><span class="c7">s1</span><span class="c3 c10">&nbsp;and </span><span class="c7">s2</span><span class="c3 c10">. After each batch of rays, we calculate the mean and variance of the radiance values as well as the tolerance defined as </span><span class="c7">1.96 * sqrt(variance / sample_count)</span><span class="c0">. If we&rsquo;re within the maximum allowed tolerance, then we calculate the pixel&rsquo;s color as the average color of the rays traced so far and return.</span></p><p class="c5"><span class="c0">Essentially, our implementation traces a batch of rays per pixel, calculates the variance of the colors returned by these rays, and if the variance is within the tolerance, we average the color of the rays traced so far, and no more rays are traced for this pixel. If the variance exceeds the tolerance, more rays are traced until either the variance falls below the tolerance or the maximum number of rays is reached. </span></p><p class="c5 c17"><span class="c0"></span></p><h3 class="c5 c13" id="h.n13d4qd2s372"><span>Images</span></h3><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.7"></a><table class="c15"><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image12.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image25.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c5"><span class="c6 c10">Left: Adaptive Sampling rendering on </span><span class="c6 c20 c10">dae/sky/CBbunny.dae</span><span class="c11 c6 c10">&nbsp;using 2048 samples per pixel, 1 sample per light, and a max depth of 5. Right: The sample rate image of the left image.</span></p><p class="c5 c17"><span class="c0"></span></p><a id="t.f727949b760321cc972232d42b2d9fa1f8785d82"></a><a id="t.8"></a><table class="c15"><tr class="c4"><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image29.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c2" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image30.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c5"><span class="c6 c10">Left: Adaptive Sampling rendering on </span><span class="c6 c20 c10">dae/sky/CBspheres_lambertian.dae</span><span class="c6 c10">&nbsp;using 2048 samples per pixel, 1 sample per light, and a max depth of 5. Right: The sample rate image of the left image.</span></p><p class="c5 c17"><span class="c0"></span></p><h2 class="c19 c13" id="h.ro7lso7m6ma0"><span class="c11 c9 c22">Collaboration</span></h2><p class="c5"><span class="c3 c10">Our schedules were both very packed, so we pretty much just worked on the assignment in our own time. We would communicate on what part we were working on, what progress we&rsquo;ve made, whether we needed assistance with the part we&rsquo;re working on, etc. Since some parts were independent from each other or could be coded up independently, sometimes we each did a part separately, and if we got stuck, we&rsquo;d just make a branch and have the other person take a look. Overall, this worked well for us, as it was accommodating to our schedules and allowed us to both get the learning benefits from this assignment, as we&rsquo;d review each others&rsquo; code for each part to ensure both correctness and proper understanding of the concepts.</span></p></body></html>