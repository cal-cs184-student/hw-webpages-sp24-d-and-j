<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=r3oQQBWBLofdqMg7Xagtphmx_9IXfkwuEX_E26t7NMz0vzZTLk4Jh8uoFf3Lfl2Hfyy5o2a_U6rzUqB3_tLRcA);.lst-kix_207k7o1r4gx-2>li:before{content:"\0025a0   "}.lst-kix_207k7o1r4gx-0>li:before{content:"\0025cf   "}.lst-kix_207k7o1r4gx-4>li:before{content:"\0025cb   "}.lst-kix_207k7o1r4gx-1>li:before{content:"\0025cb   "}.lst-kix_207k7o1r4gx-5>li:before{content:"\0025a0   "}li.li-bullet-0:before{margin-left:-9pt;white-space:nowrap;display:inline-block;min-width:9pt}.lst-kix_207k7o1r4gx-3>li:before{content:"\0025cf   "}ul.lst-kix_207k7o1r4gx-1{list-style-type:none}ul.lst-kix_207k7o1r4gx-2{list-style-type:none}ul.lst-kix_207k7o1r4gx-0{list-style-type:none}ul.lst-kix_207k7o1r4gx-5{list-style-type:none}.lst-kix_207k7o1r4gx-8>li:before{content:"\0025a0   "}ul.lst-kix_207k7o1r4gx-6{list-style-type:none}ul.lst-kix_207k7o1r4gx-3{list-style-type:none}ul.lst-kix_207k7o1r4gx-4{list-style-type:none}.lst-kix_207k7o1r4gx-6>li:before{content:"\0025cf   "}ul.lst-kix_207k7o1r4gx-7{list-style-type:none}ul.lst-kix_207k7o1r4gx-8{list-style-type:none}.lst-kix_207k7o1r4gx-7>li:before{content:"\0025cb   "}ol{margin:0;padding:0}table td,table th{padding:0}.c17{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#333333;border-top-width:1pt;border-right-width:1pt;border-left-color:#333333;vertical-align:top;border-right-color:#333333;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:288pt;border-top-color:#333333;border-bottom-style:solid}.c25{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:183.8pt;border-top-color:#000000;border-bottom-style:solid}.c24{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:174.8pt;border-top-color:#000000;border-bottom-style:solid}.c16{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:104.2pt;border-top-color:#000000;border-bottom-style:solid}.c27{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:middle;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:62.2pt;border-top-color:#000000;border-bottom-style:solid}.c28{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:189.8pt;border-top-color:#000000;border-bottom-style:solid}.c20{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:360pt;border-top-color:#000000;border-bottom-style:solid}.c19{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:181.5pt;border-top-color:#000000;border-bottom-style:solid}.c18{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:62.2pt;border-top-color:#000000;border-bottom-style:solid}.c0{color:#000000;font-weight:300;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Helvetica Neue";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c15{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Helvetica Neue";font-style:normal}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c8{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Helvetica Neue";font-style:normal}.c26{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Helvetica Neue";font-style:normal}.c21{padding-top:18pt;padding-bottom:6pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c36{padding-top:0pt;padding-bottom:16pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c32{padding-top:0pt;padding-bottom:3pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c30{text-decoration-skip-ink:none;-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline}.c35{font-weight:400;font-size:26pt;font-family:"Helvetica Neue";font-style:normal}.c7{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c10{margin-left:auto;border-spacing:0;border-collapse:collapse;margin-right:auto}.c37{background-color:#fafafa;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c12{font-size:12pt;font-family:"Courier New";font-weight:400}.c34{color:#000000;text-decoration:none;vertical-align:baseline}.c2{font-size:12pt;font-family:"Helvetica Neue";font-weight:300}.c13{padding:0;margin:0}.c31{margin-left:27pt;padding-left:-9pt}.c6{margin-left:18pt;padding-left:-9pt}.c33{color:inherit;text-decoration:inherit}.c11{page-break-after:avoid}.c23{font-style:italic}.c29{height:11pt}.c3{vertical-align:sub}.c14{height:0pt}.c22{height:171.8pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:0pt;color:#000000;font-weight:700;font-size:12pt;padding-bottom:0pt;font-family:"Helvetica Neue";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c37 doc-content"><p class="c11 c32 title" id="h.ynuhj7g8d1"><span class="c34 c35">HW1: Rasterizer</span></p><p class="c11 c36 subtitle" id="h.b0gs0jwziuy2"><span class="c26">By: Joseph Liu and Daniel Hsu</span></p><h2 class="c21 c11" id="h.66gqg7jykr8r"><span class="c15">Task 1 - Drawing Triangles</span></h2><p class="c9"><span class="c0">Rasterizing triangles is the process of sampling the continuous area constrained by 3 intersecting lines and representing it on a grid of discrete pixels. One rasterization technique is point sampling, which uses three line tests (one per edge), to efficiently determine if a point is within a triangle by checking if the point is in the half-plane above each line. If the point is within our triangle, that means the pixel corresponding to it will be considered part of the rasterized image. Other rasterization techniques covered in class include supersampling and bilinear/trilinear interpolation.</span></p><p class="c4"><span class="c0"></span></p><p class="c9"><span class="c2">Our algorithm first reordered its set of input points to be in the counterclockwise direction by checking if (x</span><span class="c2 c3">2</span><span class="c2">, y</span><span class="c2 c3">2</span><span class="c2">) is above or below the line drawn from (x</span><span class="c2 c3">0</span><span class="c2">, y</span><span class="c2 c3">0</span><span class="c2">) to</span><span class="c2">&nbsp;(x</span><span class="c2 c3">1</span><span class="c2">, y</span><span class="c2 c3">1</span><span class="c0">) using the dot product method. Then, we created the bounding box from the lowest x and y to the highest x and y coordinates (this is to reduce the number of computations). For each pixel in the bounding box, the 3-line test is performed using the dot product property.</span></p><p class="c4"><span class="c0"></span></p><p class="c9"><span class="c2 c23">We also successfully implemented this with barycentric coordinates, where we take advantage of the fact that a point lies in a triangle if the </span><img src="images/image1.png"><span class="c2 c23">&nbsp;are all non-negative. We calculated the </span><img src="images/image1.png"><span class="c2 c23">&nbsp;for each point in the bounding box and the coordinate of the triangle to rasterize, and rasterized the point if </span><img src="images/image1.png"><span class="c2 c23 c34">&nbsp;are all non-negative. We did not submit this implementation because we believed the goal of this task was to implement the three line test approach.</span></p><p class="c4"><span class="c0"></span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 447.36px; height: 335.52px;"><img alt="" src="images/image37.png" style="width: 447.36px; height: 335.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c0">ChatGPT was used as a guide for writing the code used to time the runtime of our function. Everything else is wholly made by us.</span></p><p class="c4"><span class="c0"></span></p><p class="c4"><span class="c0"></span></p><h2 class="c21 c11" id="h.p48iqjj53jy9"><span class="c15">Task 2 - Supersampling</span></h2><p class="c9"><span class="c0">Supersampling is done by sampling at multiple points in a pixel (not just the center of the pixel) and averaging the color obtained at each sampling point to achieve a smoother outline on a triangle. This is more computing intensive than rasterization without supersampling.</span></p><p class="c4"><span class="c0"></span></p><h3 class="c9 c11" id="h.5dphpfuc3f89"><span class="c8">Data Structures</span></h3><p class="c9"><span class="c2">For task 1, we sampled at a pixel and directly placed the sampled color to </span><span class="c12">sample_buffer</span><span class="c2">, a Color vector that is </span><span class="c12">width * height</span><span class="c2">&nbsp;long. But with supersampling, we have </span><span class="c12">sampling_rate * width * height</span><span class="c2">&nbsp;Colors sampled, so we resize</span><span class="c12">&nbsp;sample_buffer</span><span class="c2">&nbsp;to fit that many Colors. Inside </span><span class="c12">sample_buffer</span><span class="c2">, we place all the supersampled Colors within a pixel next to each color, so as an example if </span><span class="c12">sampling_rate = 4</span><span class="c2">, </span><span class="c12">sample_buffer</span><span class="c0">&nbsp;contains 4 supersampled Colors of a pixel followed by 4 supersampled Colors of the next pixel and so on&hellip;</span></p><p class="c4"><span class="c0"></span></p><h3 class="c9 c11" id="h.ctpxm3iujnbr"><span class="c8">Algorithms</span></h3><p class="c9"><span class="c2">Rasterization without supersampling is equivalent to taking a pixel, finding its center, and finding the color at that center. If we sample at </span><span class="c12">sample_rate = 4</span><span class="c2">, we essentially divide a pixel into 4 equivalent subpixels (2 rows and 2 columns), find their centers, find the colors at those centers, and average those colors. With </span><span class="c12">sample_rate = 9</span><span class="c2">&nbsp;it&rsquo;s divided into 9 subpixels, with 16 it&rsquo;s divided into 16 subpixels. So we modified our </span><span class="c12">rasterize_triangle()</span><span class="c2">&nbsp;algorithm to generalize this step, saving the supersampled color of each subpixel to its corresponding location in </span><span class="c12">sample_buffer</span><span class="c0">.</span></p><p class="c9"><span class="c2">Lastly, support for supersampling was given to </span><span class="c12">resolve_to_framebuffer()</span><span class="c2">&nbsp;by finding the average color of </span><span class="c12">sample_rate</span><span class="c2">&nbsp;Colors from </span><span class="c12">sample_buffer</span><span class="c0">.</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 225.00px; height: 225.00px;"><img alt="" src="images/image50.png" style="width: 301.00px; height: 225.00px; margin-left: -76.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 220.50px; height: 221.54px;"><img alt="" src="images/image32.png" style="width: 295.39px; height: 221.54px; margin-left: -74.89px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 219.71px; height: 219.71px;"><img alt="" src="images/image47.png" style="width: 293.65px; height: 219.71px; margin-left: -73.93px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c2">From left to right, sampling rates are 1, 4, and 16. As sampling rate increases, less artifacts are observed and edges appear smoother. There are jaggies and discontinuous pixels with </span><span class="c12">sample_rate = 1</span><span class="c0">&nbsp;because of how strict the rasterize function is. Say for example, an edge passes through a pixel with almost half of the pixel being inside the triangle but the pixel center is not in the triangle. In this case, this pixel would not be colored with that of the triangle. But if this triangle is supersampled at a rate of 4, the center(s) of one or two subpixels would fall within the triangle. After averaging colors, the pixel will have some color of the triangle (be that &frac14; or &frac12;). And the higher the sampling rate, the more fine-tuned we can get with finding the actual percentage of how much a triangle lies within a pixel. And with the color of pixels closer to the actual color contributed by the triangle, the color disparity between adjacent pixels will not be so extreme, thus making the lines look smoother due to more gradual transitions. So, this is why higher sampling rates lead to less aliasing.</span></p><p class="c4"><span class="c0"></span></p><h2 class="c21 c11" id="h.3lkn161017bg"><span class="c15">Task 3 - Transforms</span></h2><p class="c9"><span class="c2">We applied the transforms to make cubeman jump for joy because we&rsquo;ve made it to the halfway point of this assignment!</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 493.50px; height: 369.28px;"><img alt="" src="images/image49.png" style="width: 493.50px; height: 369.28px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><img src="images/image2.png"></p><p class="c4"><span class="c0"></span></p><h2 class="c21 c11" id="h.ppvjqtsnekc8"><span class="c15">Task 4 - Barycentric Interpolation</span></h2><p class="c9"><span class="c2">Barycentric coordinates are a means to specify a point within a triangle and express it as proportions of the triangle&rsquo;s three vertices. We define these proportions </span><img src="images/image1.png"><span class="c2">&nbsp;such that </span><img src="images/image3.png"><span class="c2">, which correspond to </span><img src="images/image4.png"><span class="c2">&nbsp;respectively. Essentially, each we can think of it like this: vertex </span><img src="images/image5.png"><span class="c2">&nbsp;pulls on the point with strength </span><img src="images/image6.png"><span class="c2">, 1 meaning it pulls the point all the way toward itself, meaning the point is the vertex </span><img src="images/image5.png"><span class="c0">; and same for the other two points.</span></p><p class="c9"><span class="c2">In the below illustration, we assign a color to each vertex: </span><img src="images/image5.png"><span class="c2">&nbsp;is red, </span><img src="images/image7.png"><span class="c2">&nbsp;is green, and </span><img src="images/image8.png"><span class="c2">&nbsp;is blue. Wherever the point is, it is a linear combination of the weights </span><img src="images/image1.png"><span class="c2">&nbsp;on the values assigned to </span><img src="images/image4.png"><span class="c2">. In the illustration, we see that </span><img src="images/image9.png"><span class="c2">&nbsp;is somewhat half way between </span><img src="images/image7.png"><span class="c2">&nbsp;and </span><img src="images/image8.png"><span class="c2">&nbsp;and quite far away from </span><img src="images/image5.png"><span class="c0">. Hence, the interpolated color is a roughly even mix of green and blue with just a hint of red.</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 501.25px; height: 407.48px;"><img alt="" src="images/image45.png" style="width: 501.25px; height: 407.48px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span>[SOURCE: </span><span class="c30"><a class="c33" href="https://www.google.com/url?q=https://cs184.eecs.berkeley.edu/sp24/lecture/5-18/texture&amp;sa=D&amp;source=editors&amp;ust=1707984657149640&amp;usg=AOvVaw0HyuAfBuoTlqn4dtjPwYCN">https://cs184.eecs.berkeley.edu/sp24/lecture/5-18/texture</a></span><span class="c5">]</span></p><p class="c4"><span class="c5"></span></p><p class="c9"><span class="c2">Here is a </span><span class="c2 c23">png</span><span class="c2">&nbsp;screenshot of </span><span class="c2 c23">png/basic/test7.svg</span><span class="c2">. </span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 632.36px; height: 474.27px;"><img alt="" src="images/image52.png" style="width: 632.36px; height: 474.27px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c5"></span></p><p class="c4"><span class="c5"></span></p><h2 class="c11 c21" id="h.4gw8wxib6gry"><span class="c15">Task 5 - Pixel Sampling</span></h2><p class="c9"><span class="c0">Pixel sampling is the process in which we determine the color of a pixel by sampling the texture image. Essentially, each pixel on the surface we&rsquo;re applying the texture to has a corresponding UV coordinate (between 0 and 1) which maps it to a corresponding texel on the texture image. There are different ways in which we can choose to sample the texture. We implemented two ways of doing this: nearest neighbor and bilinear interpolation. </span></p><p class="c4"><span class="c0"></span></p><h3 class="c9 c11" id="h.qfaj3nq7htd2"><span class="c8">Nearest Neighbor</span></h3><p class="c9"><span class="c2">The nearest-neighbor approach samples by simply picking the closest pixel sample at that part of the texture. We implemented this by first converting the UV coordinates to the pixel coordinates on the mipmap. This is done by simply multiplying </span><img src="images/image10.png"><span class="c2">&nbsp;and </span><img src="images/image11.png"><span class="c0">&nbsp;by the width and height respectively (since UV coordinates are between 0 and 1) and then casting them as integers to get the nearest integer coordinate. We then call mip.get_texel to get the texel at the texture coordinate.</span></p><p class="c4"><span class="c0"></span></p><h3 class="c9 c11" id="h.4ex1v09zkb6g"><span class="c8">Bilinear Interpolation</span></h3><p class="c9"><span class="c0">Bilinear interpolation samples by interpolating the values from the four nearest pixels that form a box around the point we are trying to sample.</span></p><p class="c9"><span class="c2">Firstly, we converted the UV coordinate to pixel coordinates by multiplying </span><img src="images/image10.png"><span class="c2">&nbsp;by the width and </span><img src="images/image11.png"><span class="c2">&nbsp;by the height of the mip; we store these as </span><img src="images/image12.png"><span class="c2">&nbsp;and </span><img src="images/image13.png"><span class="c2">. Now, since the four pixels we&rsquo;re interpolating from form a box, we calculate </span><img src="images/image14.png"><span class="c2">&nbsp;(left x-coordinate), </span><img src="images/image15.png"><span class="c2">&nbsp;(right x-coordinate), </span><img src="images/image16.png"><span class="c2">&nbsp;(bottom y-coordinate), and </span><img src="images/image17.png"><span class="c2">&nbsp;(top y-coordinate). With these four, we can combine them to get the coordinates of the four points. Using what we found above, we find the fractional offsets </span><img src="images/image18.png"><span class="c2">&nbsp;and </span><img src="images/image19.png"><span class="c0">.</span></p><p class="c9"><span class="c0">Next we get the values of the texels from the mip at the four pixel coordinates in the same we we saw in lecture:</span></p><p class="c9"><span class="c2">&nbsp;</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 205.00px; height: 225.40px;"><img alt="" src="images/image51.png" style="width: 205.00px; height: 225.40px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c9"><span class="c2">Then we perform two lerp steps &ndash; we interpolate the two bottom points to get </span><img src="images/image20.png"><span class="c2">&nbsp;and the two top points to get </span><img src="images/image21.png"><span class="c2">, using the interpolation weight </span><img src="images/image22.png"><span class="c2">. Then we lerp-ed </span><img src="images/image20.png"><span class="c2">&nbsp;and </span><img src="images/image21.png"><span class="c2">&nbsp;using the interpolation weight </span><img src="images/image23.png"><span class="c0">&nbsp;to get the value at our sample point.</span></p><p class="c4"><span class="c0"></span></p><p class="c9"><span class="c0">Below are the screenshots for part of the parrot&rsquo;s mouth (right below its beak). This part was chosen due to it containing high frequency transitions between colors, for which we wanted to see how each sampling method at different sampling rates deal with this.</span></p><a id="t.92174b4b82610f669b7a807f33d9d9d3dc9cc27f"></a><a id="t.0"></a><table class="c10"><tr class="c14"><td class="c27" colspan="1" rowspan="1"><p class="c1 c29"><span class="c0"></span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c1"><span class="c8">Nearest Neighbor</span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c1"><span class="c8">Bilinear Interpolation</span></p></td></tr><tr class="c14"><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c8">1 sample per pixel</span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 803.94px; height: 596.92px;"><img alt="" src="images/image40.png" style="width: 2046.80px; height: 1626.37px; margin-left: -1242.86px; margin-top: -0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 795.39px; height: 629.33px;"><img alt="" src="images/image38.png" style="width: 2048.00px; height: 1627.00px; margin-left: -1252.61px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c22"><td class="c18" colspan="1" rowspan="1"><p class="c1"><span class="c8">16 samples per pixel</span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 226.00px; height: 201.81px;"><img alt="" src="images/image36.png" style="width: 578.58px; height: 476.84px; margin-left: -352.58px; margin-top: -0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c24" colspan="1" rowspan="1"><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 833.49px; height: 727.85px;"><img alt="" src="images/image35.png" style="width: 2048.00px; height: 1700.64px; margin-left: -1214.51px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c4"><span class="c0"></span></p><p class="c9"><span class="c0">We see from this that bilinear interpolation produces much higher quality sampling of the texture than nearest neighbor. Nearest neighbor tends to be a lot more &ldquo;blocky&rdquo; and has sharp and abrupt transitions between different colors. Even sampling at 16 samples per pixel, we see that nearest neighbor still contains a good deal of color banding and rough edges. This is because nearest neighbor just picks the closest pixel, which may cause it to miss some intermediate pixels/colors due to the discrete nature of its sampling. In bilinear interpolation, we see a much smoother blend between the colors while still featuring the details of the high-frequency transition between colors. This is because bilinear interpolation interpolates, or essentially averages between pixels nearby the sample point. Whereas in nearest neighbor, we saw jumps in color which gives a pixelated effect, in bilinear interpolation we see smoother gradients and more natural transitions.</span></p><p class="c9"><span class="c0">Between 1 sample per pixel and 16 samples per pixel, we see a large improvement in the quality for the nearest neighbor sampling. This is because supersampling already reduces the pixelation effect by sampling multiple points via blending for smoother transitions between colors. This means that when nearest neighbor goes and picks the texels, the high-frequency changes are already smoothed out a bit, so it will be able to sample more of the intermediate colors where there is high-frequency change. The effect of increasing sample rate is not as pronounced for bilinear interpolation, mainly because the supersampling process and the bilinear interpolation process are very similar in that they both interpolate/average surrounding pixels for a smoother effect.</span></p><p class="c9"><span class="c0">In general, we will observe a large difference between nearest neighbor and bilinear interpolation where there are abrupt, high-frequency changes in the texture image. This is because nearest neighbor tends to miss intermediate pixels where there is a quick, sudden change in color, whereas bilinear interpolation handles this by going and blending the pixels.</span></p><p class="c4"><span class="c0"></span></p><h2 class="c21 c11" id="h.hs1937hq6q77"><span class="c15">Task 6 - Level Sampling</span></h2><p class="c9"><span class="c0">Level sampling, or mipmapping, is the process of selecting the appropriate level of detail for a texture depending on the distance of the textured objects (which results from perspective or 3D graphics). Particularly, level sampling addresses aliasing artifacts when texturing objects that are perceived to be &ldquo;far away&rdquo;, where minification is required to render the texture at a size smaller than its original resolution. Minification leads to loss of detail and aliasing because high-frequency changes in color are undersampled. We account for this using a mipmap, which is essentially a series of pre-generated versions of the texture at different resolutions. This way, for closeby objects, we can maintain a high detail by using the higher resolution version of the texture, and avoid aliasing for faraway objects by using the lower resolution, antialiased version of the texture.</span></p><p class="c4"><span class="c0"></span></p><p class="c9"><span class="c2">The level is calculated with derivatives </span><img src="images/image24.png"><span class="c2">&nbsp;which are obtained with </span><img src="images/image25.png"><span class="c2">. This means we need to calculate 2 more of each &#593;, &#42933;, and &#120574;; one at </span><img src="images/image26.png"><span class="c2">&nbsp;and one at </span><img src="images/image27.png"><span class="c2">&nbsp;to get </span><img src="images/image28.png"><span class="c2">&nbsp;and </span><img src="images/image29.png"><span class="c2">&nbsp;respectively. After computing </span><img src="images/image30.png"><span class="c2">, the level is simply </span><img src="images/image31.png"><span class="c0">. With nearest-level, we round D to the closest integer. With linear-level, we lerp the color contributions of the mipmaps with levels floor(D) and ceil(D).</span></p><p class="c4"><span class="c0"></span></p><a id="t.f28033f3a7a1a6dc87b16746b293518de1572c00"></a><a id="t.1"></a><table class="c10"><tr class="c14"><td class="c16" colspan="1" rowspan="1"><p class="c7"><span class="c0">Sampling method</span></p></td><td class="c19" colspan="1" rowspan="1"><p class="c1"><span class="c0">Supersampling</span></p></td><td class="c28" colspan="1" rowspan="1"><p class="c1"><span class="c0">Pixel sampling</span></p></td><td class="c25" colspan="1" rowspan="1"><p class="c1"><span class="c0">Level sampling</span></p></td></tr><tr class="c14"><td class="c16" colspan="1" rowspan="1"><p class="c7"><span class="c0">Pros</span></p></td><td class="c19" colspan="1" rowspan="1"><ul class="c13 lst-kix_207k7o1r4gx-0 start"><li class="c1 c6 li-bullet-0"><span class="c0">Useful in both minification and magnification (best AA)</span></li></ul></td><td class="c28" colspan="1" rowspan="1"><ul class="c13 lst-kix_207k7o1r4gx-0"><li class="c1 c6 li-bullet-0"><span class="c0">Most memory efficient</span></li><li class="c1 c6 li-bullet-0"><span class="c0">Fastest (lerp is quite fast)</span></li></ul><ul class="c13 lst-kix_207k7o1r4gx-1 start"><li class="c1 c31 li-bullet-0"><span class="c2">Require a square root, however, to compute </span><span class="c8">D</span></li></ul></td><td class="c25" colspan="1" rowspan="1"><ul class="c13 lst-kix_207k7o1r4gx-0"><li class="c1 c6 li-bullet-0"><span class="c0">Rather memory efficient because mipmaps are 4/3 the size of the original texture</span></li></ul></td></tr><tr class="c14"><td class="c16" colspan="1" rowspan="1"><p class="c7"><span class="c0">Cons</span></p></td><td class="c19" colspan="1" rowspan="1"><ul class="c13 lst-kix_207k7o1r4gx-0"><li class="c1 c6 li-bullet-0"><span class="c0">Most memory intensive (if storing all supersampled colors)</span></li><li class="c1 c6 li-bullet-0"><span class="c0">Compute time is linear to sample rate</span></li></ul><ul class="c13 lst-kix_207k7o1r4gx-1 start"><li class="c1 c31 li-bullet-0"><span class="c0">Computing &#593;, &#42933;, and &#120574; are most intensive</span></li></ul></td><td class="c28" colspan="1" rowspan="1"><ul class="c13 lst-kix_207k7o1r4gx-0"><li class="c1 c6 li-bullet-0"><span class="c0">Bilinear AA not as powerful as supersampling</span></li></ul></td><td class="c25" colspan="1" rowspan="1"><ul class="c13 lst-kix_207k7o1r4gx-0"><li class="c1 c6 li-bullet-0"><span class="c0">Nearest and trilinear are only useful in minification</span></li><li class="c1 c6 li-bullet-0"><span class="c0">Trilinear is ~2x more compute intensive than bilinear (but still faster than supersampling at 9 or 16)</span></li></ul></td></tr></table><p class="c4"><span class="c0"></span></p><p class="c9"><span class="c0">Original image:</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 800.00px; height: 800.00px;"><img alt="" src="images/image33.png" style="width: 800.00px; height: 800.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c0"></span></p><a id="t.8a5856ed9e7ed4c95b4a9e6770943a753e235f92"></a><a id="t.2"></a><table class="c10"><tr class="c14"><td class="c17" colspan="1" rowspan="1"><p class="c9"><span class="c0">L_ZERO and P_NEAREST</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 358.40px; height: 275.91px;"><img alt="" src="images/image46.png" style="width: 639.62px; height: 477.86px; margin-left: -281.22px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c9"><span class="c0">L_ZERO and P_LINEAR</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 358.40px; height: 277.05px;"><img alt="" src="images/image43.png" style="width: 639.62px; height: 479.83px; margin-left: -281.22px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c14"><td class="c17" colspan="1" rowspan="1"><p class="c9"><span class="c0">L_NEAREST and P_NEAREST</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 358.40px; height: 280.91px;"><img alt="" src="images/image41.png" style="width: 639.62px; height: 486.51px; margin-left: -281.22px; margin-top: -0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c9"><span class="c0">L_NEAREST and P_LINEAR</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 357.60px; height: 277.02px;"><img alt="" src="images/image34.png" style="width: 639.78px; height: 479.78px; margin-left: -282.18px; margin-top: -0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr><tr class="c14"><td class="c17" colspan="1" rowspan="1"><p class="c9"><span class="c0">L_LINEAR and P_NEAREST</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 358.40px; height: 277.05px;"><img alt="" src="images/image48.png" style="width: 639.62px; height: 479.81px; margin-left: -281.22px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c17" colspan="1" rowspan="1"><p class="c9"><span class="c0">L_LINEAR and P_LINEAR</span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 358.40px; height: 277.05px;"><img alt="" src="images/image44.png" style="width: 639.62px; height: 479.81px; margin-left: -281.22px; margin-top: -0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c4"><span class="c0"></span></p><a id="t.f61da5aa766840896b6f7001518a39f9bcb0d12d"></a><a id="t.3"></a><table class="c10"><tr class="c14"><td class="c20" colspan="1" rowspan="1"><p class="c1"><span class="c0">L_ZERO and P_NEAREST (looks the same as L_NEAREST and P_NEAREST and L_LINEAR and P_NEAREST)</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 800.00px; height: 600.00px;"><img alt="" src="images/image42.png" style="width: 800.00px; height: 600.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td><td class="c20" colspan="1" rowspan="1"><p class="c1"><span class="c0">L_ZERO and P_LINEAR (looks the same as L_NEAREST and P_LINEAR and L_LINEAR and P_LINEAR)</span></p><p class="c1"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 800.00px; height: 600.00px;"><img alt="" src="images/image39.png" style="width: 800.00px; height: 600.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c4"><span class="c0"></span></p><p class="c4"><span class="c0"></span></p></body></html>